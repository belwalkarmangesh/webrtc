#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
WebRTC
\begin_inset CommandInset label
LatexCommand label
name "sub:WebRTC"

\end_inset


\end_layout

\begin_layout Standard
As WebRTC is an integral part of the project, a lot of early research has
 gone into reading the official W3C WebRTC specifications
\begin_inset CommandInset citation
LatexCommand cite
key "w3cwebrtcspec"

\end_inset

 and producing prototypes that demonstrate the uses of the technology.
 In this research phase of the project we've experimented with different
 techniques for establishing connections, methods of sending and receiving
 data and developing a useful application structure.
 We will detail our findings on WebRTC below, and provide some insight on
 the inner workings of WebRTC.
\end_layout

\begin_layout Subsubsection
API differences
\end_layout

\begin_layout Standard
We found early on that even though the Firefox and Chrome web browsers are
 able to communicate to each other through WebRTC, they don't yet use the
 same JavaScript API for their connections.
 Comparing their respective APIs with the official WebRTC specifications
 we found that Chrome's implementation came closest, and keeping in mind
 that we were merely conducting research on WebRTC and not building a consumer
 product, we decided to drop support for Firefox.
 We had our hopes that Firefox would fix their implementation but as of
 this writing this has yet to happen.
 We do expect that Mozilla, Firefox's developer, will eventually bow to
 the official specifications and that our library will work on it as well.
\end_layout

\begin_layout Subsubsection
Establishing a peer connection
\end_layout

\begin_layout Standard
Reliably establishing a peer-to-peer connection between two consumer devices
 is not a trivial matter.
 While web servers are usually designed around accepting connections and
 have their own external IP-address, consumer devices are often protected
 by firewalls and located behind a Network Address Translation service (NAT).
 WebRTC utilizes several technologies to enable peers to connect through
 environments that limit the connectivity of the peers.
 
\end_layout

\begin_layout Standard
ICE, Interactive Connectivity Establishment
\begin_inset CommandInset citation
LatexCommand cite
key "ietficespec"

\end_inset

, is a technique for NAT-traversal for UDP-based media streams, although
 in practice ICE isn't limited to UDP alone and can also be applied to TCP.
 ICE makes use of the offer/answer model, where party A sends a connection
 offer to party B including its preferred connection terms and aspects -
 such as bandwidth and protocol version - and party B responds to party
 A with the terms it agrees to.
 These offers and answers are in a format defined by the Session Description
 Protocol, which is a standard created back in 1998 to assist in setting
 up streaming media connections such as Bluetooth headsets streaming audio
 to and from mobile phones and videoconferencing where both video and audio
 are streamed between a multitude of entities.
 
\end_layout

\begin_layout Subsubsection*
STUN and TURN
\end_layout

\begin_layout Standard
ICE heavily relies on STUN, Session Traversal Utilities for NAT
\begin_inset CommandInset citation
LatexCommand cite
key "ietfstunspec"

\end_inset

, to discover whether or not the application is located behind a NAT.
 STUN does this by calling a so-called STUN-server and query the server
 to retrieve the IP-address and port of the requesting party.
 If this IP-address doesn't match the locally known IP-address (link address),
 the application is located behind a NAT.
 The discovered external IP-address and port are then included in the connection
 offer or answer by encoding them into the SDP packet.
\end_layout

\begin_layout Standard
TURN, Traversal Using Relay NAT
\begin_inset CommandInset citation
LatexCommand cite
key "ietfturnspec"

\end_inset

, is an extension on STUN.
 It allows ICE connections to be relayed by a TURN-server, which means that
 even when the user is behind an aggressive firewall or problematic NAT,
 ICE connections can be established by having the TURN-server relay all
 packets.
 In contrast to STUN-servers, which are freely provided for public use by
 a number of entities, TURN-servers are usually not free and have to be
 self hosted or rented from a third party.
\end_layout

\begin_layout Subsubsection*
Signaling channels
\end_layout

\begin_layout Standard
Before a peer connection is established, the peers have to exchange the
 connectivity information in the form of SDP packets.
 Since there's no connection between these peers yet, these packets have
 to be routed through a third party that can communicate with either node,
 also called a signaling channel.
 The official W3C WebRTC specifications do not provide a detailed description
 on what form this signaling channel should take on and instead leave it
 to the developer to guide the exchange of SDP packets.
 We identified several possible manners to achieve this initialization.
 
\end_layout

\begin_layout Itemize
Using a web server, one can use AJAX requests which in turn routes information
 from one peer to the other, but this has the disadvantage that any peer
 has to be aware that the other peer is requesting a connection, or that
 the use of continuous AJAX polling, continuously requesting the server
 for an update, is required.
 
\end_layout

\begin_layout Itemize
Another way to establish the connection is to have all peers connected to
 a web server using a WebSocket, a technology which provides full continuous
 communication between the browser and a web server, and is always available
 and open for sending and receiving data.
 SDPs can then be easily routed through this web server.
\end_layout

\begin_layout Itemize
Apart from that, it would in theory be possible to use a DNS discovery technique
s such as Apple's Bonjour to detect WebRTC nodes on the local network, but
 this isn't (yet) possible without the use third party plugins.
 
\end_layout

\begin_layout Itemize
Aside from using a web server or nonexistent technology, it would also be
 possible, although cumbersome, to exchange the information in manually,
 like using QR-encoding to encode the SDP into an image which can be scanned
 by another machine.
\end_layout

\begin_layout Subsubsection*
WebSockets
\end_layout

\begin_layout Standard
The choice of which technology to use for the signaling channel was a relatively
 easy one: WebSockets seemed to be the best technology for our purposes
 as it has very few downsides and provides a reliable way for exchanging
 data, and this choice was backed up by numerous sources on the internet
 where the use of WebSockets as signaling channel was ubiquitous among WebRTC
 applications.
 This choice, however, requires a more advanced web server than the well-known
 Apache-PHP-MySQL setup which runs a better part of the internet.
 
\end_layout

\begin_layout Standard
Among the possibilities, which also included a custom Java server or Ruby-on-Rai
ls, we found that a NodeJS server best fit our needs, not the least because
 NodeJS, like web browsers, runs JavaScript.
 This means that both client and server are able to run the same code, which
 has the advantages of slimming down the code base by avoiding the duplication
 of functionality and make the whole application less error prone because
 the shared functionality has to be tested only once instead of twice.
 NodeJS is perfectly capable of opening and maintaining numerous WebSocket
 connections to provide the signaling functionality we require.
\end_layout

\begin_layout Subsubsection
Exchanging data
\end_layout

\begin_layout Standard
Once a connection has been established, exchanging data is trivial.
 Data channels, for sending raw data, and media streams can be added quite
 easily, although then the connection terms have to be renegotiated.
 This means that that whole offer/answer process has to be repeated, except
 when a data channel is already open the SDP packets don't have to be routed
 through the server but can be sent to the peer directly.
 To avoid renegotiation, one can also add a data channel or media stream
 to the connection prior to generating the offer, so that these are included
 in the initial SDP.
\end_layout

\begin_layout Standard
In our prototypes, we found that data channels are by default ratelimited
 to 30 kilobits per second, and if one attempted to send data faster, WebRTC
 would throw mysterious and indescriptive error messages.
 After some research we discovered that the (automatically generated) SDP
 packet generated at initialization can be simply edited to increase the
 data rate, although this method is very unintuitive and feels a bit awkward.
 For now, however, this seems to be the only way to achieve a useful rate
 of data flow for the channel.
\end_layout

\begin_layout Standard
Another peculiar detail of the data channel implementation in Chrome is
 that the SDP packet to instantiate the WebRTC connection is too large to
 send through a WebRTC data channel.
 This has the implication that, without intervening, peers cannot renegotiate
 their own connections.
 This we found of course to be unacceptable and led to devising a way to
 split up packets before transmitting them, and reassembling them on the
 other side.
 Looking back this is a must-have feature regardless of the size of the
 SDP packet, as this means that we can make any packet arbitrarily large
 without any problems.
\end_layout

\begin_layout Subsection
Peer-to-Peer
\begin_inset CommandInset label
LatexCommand label
name "sub:Peer-to-Peer"

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Assignment-formulation"

\end_inset

 we already have defined that the type of peer-to-peer application will
 be a browser based game.
 Out research on peer-to-peer networks will consequently be related to our
 choice.
\end_layout

\begin_layout Subsubsection
Node heterogeneity
\end_layout

\begin_layout Standard
Our goal is to create a stable, fast performing network with WebRTC technology.
 It is important to realize that every node which wants to connect to the
 network is different, and thus will not perform the on same way.
 According to Jan Sacha 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset

, a node has a lot of characteristics to consider.
 We will sum them up.
\end_layout

\begin_layout Standard
A node has a session duration defined by the amount of time a node is in
 the network or expected to stay in the network.
 In our case of an arcade action game, a player will join for a period between
 1 minute and 1 hour.
 A small session duration will make the stability of network vulnerable.
\end_layout

\begin_layout Standard
Availability of the node is the next property, defined by a fraction of
 time a node spends in the network within longer period of time.
 This is important for availability of files for file sharing purposes.
 The files that should be distributed through the network are the library
 files - to make connection to peers and the game files - to actually play
 the game.
 Availability plays a role if the game files are being delivered through
 different peers.
 Longer availability means more peers in network what means a more stable
 network and better delivery.
 However this property is less important.
\end_layout

\begin_layout Standard
A more important characteristic of a node is bandwidth.
 Our application should be able to send a huge amount of data to all connected
 nodes.
 This could be a bottleneck for network heavy applications.
 Therefore by structuring a network, this can be an important factor.
\end_layout

\begin_layout Standard
Sending a large amount of data leads to processing a large amount of data.
 That is why memory, CPU, GPU and disk space can be important not only for
 the game experience but also for the network.
 Also the problems processing a game can lead to slower processing of the
 network functionality.
\end_layout

\begin_layout Standard
Some of the nodes can be located behind firewalls and be only able to connect
 to a limited amount of nodes.
 It is definitely our goal to ensure everyone who is able make a WebRTC
 connection to at least one of the nodes (and that is not so hard, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:WebRTC"

\end_inset

 ), can communicate to all others.
 Therefor, we have to provide a path that allows every node to reach every
 other node.
 This connectivity is one of our key properties that allows our players
 to play the game with each other.
\end_layout

\begin_layout Standard
Jan Sacha also mentions the amount of shared files and the amount of traffic
 generated by the nodes as properties of the nodes.
 This is mostly important for file sharing purposes.
\end_layout

\begin_layout Standard
According to Sharad Agarwal and Jacob R.
 Lorch
\begin_inset CommandInset citation
LatexCommand cite
key "Agarwal:2009:MOG:1594977.1592605"

\end_inset

, one of the most important properties for online peer-to-peer games is
 the latency.
 Reaction speed is essential for the real-time arcade action games.
 A small delay can be experienced as laggy by users.
 Therefore, latency will be one of the key node properties, we should consider
 while implementing our network.
\end_layout

\begin_layout Subsubsection
Structuring the network
\end_layout

\begin_layout Standard
Now we know that there are differences between nodes, we should pick a network
 topology which fits the best for our network technology - WebRTC and our
 goal application - arcade action game.
 A lot of research is done in this field, so we decided to check the existent
 topologies and in first to not try to come up with our own.
\end_layout

\begin_layout Standard
WebRTC is a new technology and first we decided to run some tests of how
 the WebRTC unstructured overlay network will perform, so if all nodes will
 be connected to all other nodes and send a significant amount data through.
 Already after 15 nodes the network started to display connection errors
 and sometimes failed to successfully send a message.
 Off course, you can quickly see that this is not the way to go, so we should
 structure the network.
\end_layout

\begin_layout Standard
Leitao 
\begin_inset CommandInset citation
LatexCommand cite
key "Leitão_onthe"

\end_inset

 summarized a couple of guidelines that introduce some degree of structure
 in randomly overlay networks.
\end_layout

\begin_layout Enumerate
So should every adaptation of the system involve a limited number of nodes.
\end_layout

\begin_layout Enumerate
Each adaptation should also use limited information to reduce communication
 between nodes for scalability purposes.
\end_layout

\begin_layout Enumerate
The adaption mechanisms should not break the network if a node functions
 with a limited or incorrect information.
 This can be expected in large networks.
\end_layout

\begin_layout Enumerate
A network should strive to keep an up-to-date track of all nodes connected
 to the network to ensure the connectivity of each node is constant.
\end_layout

\begin_layout Enumerate
The adaption mechanisms should dynamically improve the network stability.
\end_layout

\begin_layout Enumerate
Different application should be able to be run on the designed overlay network.
\end_layout

\begin_layout Standard
These best practices should be taken in mind while researching the different
 implementation of the overlay networks.
 Especially guideline 4 is very important for our game application.
 Each player should always be aware of all other players participating in
 the game and he should always have a route to communicate with him with
 as little as possible delay.
 This will be our base by investigating the peer-to-peer network topologies.
\end_layout

\begin_layout Subsubsection
Supernode topologies and approaches
\end_layout

\begin_layout Standard
A supernode is a node who acts like a server to a group of clients, we can
 compare it to parent-child relationship.
 A supernode also acts as an equal to other supernodes - a sibling relationship.
 These connected supernodes form a supernode overlay network which handles
 the core functionality of the network.
 Network topologies that implement an supernode structure make use of the
 heterogeneity of the nodes.
 There is a lot of research done on supernode topologies..
 The key question in here is: How many supernodes are desired and which
 node is the best candidate? 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset

 
\end_layout

\begin_layout Standard
Because of the enormous amount of the supernode algorithms we will split
 them in different categories.
 Jan Sacha defines four groups that use a different supernode election mechanism
s:
\end_layout

\begin_layout Enumerate

\series bold
Simple approaches
\series default
 are the first generation algorithms.
 Here are no supernode election processes described or the election approach
 is very simple or static.
 Some algorithms in this group use a central server to assign a supernode.
 Simple approaches of supernode selection don't produce an optimal network
 topology, so we disregard this class.
\end_layout

\begin_layout Enumerate

\series bold
Group based
\series default
 algorithms split a node population in different groups and elect a supernode
 independently.
 The grouped are usually split by peer properties like network proximity.
 Group based algorithms have as advantage that a global supernode election
 problem can be decomposed in local group-level supernode selection problem.
 As disadvantage are these groups hard to create and manage
\end_layout

\begin_layout Enumerate

\series bold
DHT based
\series default
 algorithms make use of the well-know DHT peer-to-peer system.
 In this class nodes use a DHT overlay to discover which nodes are close
 to them in a DHT defined space.
 The advantage of the DHT-based systems is that parent-children clusters
 can be split and merged very easily.
 However these algorithms can not real time select a supernode and distribute
 the clients to the supernodes.
 This is an important aspect of our game, so we disregard this class.
\end_layout

\begin_layout Enumerate

\series bold
Adaptive algorithms
\series default
 elect supernodes based on pre defined rules, for example: the maximum number
 of clients a supernode can have.
\end_layout

\begin_layout Standard
We chose the group based algorithms to go further with because of the decentrali
zed approach of supernode selection.
 However the rule sets of the adaptive algorithms can also be very valuable
 during the implementation of the group base algorithm.
\end_layout

\begin_layout Subsubsection
Group based network systems
\end_layout

\begin_layout Standard
We would like to compare a couple of group based systems below.
 They are divided into three classes by how nodes are organized.
 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset


\end_layout

\begin_layout Enumerate
Location-based systems are organized by their physical location, defined
 for example by communication latency between two nodes.
\end_layout

\begin_layout Enumerate
Semantic based systems are organized by their semantics.
 For example it could be a node position in the game world.
\end_layout

\begin_layout Enumerate
Grid based systems are organized by an administrative domain.
 The large-scale grid consists of small-scale grids what are actually a
 network themselves.
\end_layout

\begin_layout Standard
The choice of structuring the nodes was a tough one.
 Location based systems are better for optimal communication for all purposes,
 while semantic based systems can implement the structure for specific purposes.
 In our game example for example, you would not send any data to a player
 who can not interact with you.
 We choose to implement a location-based structure to keep our library useful
 for the different purposes.
\end_layout

\begin_layout Subsubsection
Location based systems
\end_layout

\begin_layout Standard
Now we made a choice which type of algorithm we are going to use, we started
 to discover the available systems.
 Below four proposed systems are described.
\end_layout

\begin_layout Enumerate

\series bold
Crown
\series default
 is organizes the network by the prefix of the ip of the user.
 The users with the same prefix are likely to have low latency and high
 bandwidth.
 Nodes in the same group elect a supernode with criteria of high bandwidth,
 high availability, large computational power and a low load 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/euc/WangTL04"

\end_inset

.
 This approach looks very simple and sorting the nodes by ip can be very
 unreliable.
 Also no situation is described when there are too much nodes in the same
 group.
\end_layout

\begin_layout Enumerate

\series bold
PASS
\series default
 (Peer-to-peer Asymmetric file Sharing System), like the name says it is
 designed for sharing files.
 The approach is similar to crown by grouping the nodes by latency.
 An interesting idea here is that PASS introduces a strong single node that
 handles all communication between separate groups.
 Also in PASS a supernode keeps track a backup supernode for case it leaves.
\begin_inset CommandInset citation
LatexCommand cite
key "conf/saint/KwonR03"

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
PoPCorn
\series default
 uses an external algorithm like Vivaldi to structure the network in n-dimension
al space.
 First a token is given to a random node, after he decides to negotiate
 with his peers if he 4may keep it.
 He advertises his token and calculates the combined repulsion force of
 all other tokens in the network.
 If the force is lower than a certain threshold for a certain number of
 time steps, a node may keep it and becomes a supernode.
 This approach does not describe how a token generation works in a real
 time scenario 
\begin_inset CommandInset citation
LatexCommand cite
key "Lo:2005:SSS:1090948.1091371"

\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Wolf and Merz 
\series default
heuristic evolutionary algorithm tries to minimize the distance between
 the supernodes and their clients and the distance between the supernodes.
 This algorithm uses the local search principle to hopefully find a suitable
 solution 
\begin_inset CommandInset citation
LatexCommand cite
key "wolf"

\end_inset

.
 An interesting fact is that in 
\begin_inset CommandInset citation
LatexCommand cite
key "wolf"

\end_inset

 illustrates that location based supernode selection problem a NP-hard is.
\end_layout

\begin_layout Standard
We chose for the PoPCorn algorithm because the organization of nodes based
 on latency aims to reach the fastest communication in the network.
 The token distribution principle seems reliable to dynamically elect the
 supernodes dependent of the real time coordinates.
 However a lot of implementation details are missing which offers an opportunity
 to edit PoPCorn to our own needs.
 The technical design explained later in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Network-Topology"

\end_inset


\end_layout

\begin_layout Subsection
MMOG
\end_layout

\begin_layout Standard
The game is our second delivery with the only purpose to demonstrate the
 functionality of our networkinglibrary in a fun way.
 Therefore we did not properly design a game and just brainstormed about
 gameideas until we found something we all liked.
\end_layout

\begin_layout Standard
For a game we had two different options.
 We would either make a fast-paced action game where low latency is essential
 or a role-playing-game where a low latency was not absolutely necessary.
\end_layout

\begin_layout Standard
Because WebRTC offers low-latency data channels we picked the first option.
 We did not want to create a generic first-person shooter though because
 that did not interest anyone in our group.
\end_layout

\begin_layout Standard
We did pick a 3D dog fighting game around a planet with little 
\begin_inset Quotes eld
\end_inset

alien
\begin_inset Quotes erd
\end_inset

-spaceships.
 Every player controls a single spaceship in 3rd person view.
 When the player descends to quickly he or she will crash into the planet
 and die.
 Players can also fire small projectiles that kill other players on hit
 as well.
 To further demonstrate synchronization in the network, the game contains
 a leaderboard showing all accumulated kills and deaths of active players.
\end_layout

\begin_layout Standard
We also picked this game idea because initially we wanted to create an applicati
on or game that would make extensive use of orientation sensors in the users
 smartphone.
 This quickly changed to be a desktop game but we still liked the idea of
 being able to control the game with a smartphone.
\end_layout

\begin_layout Standard
Therefore the ability to fly the spaceship by tilting the phone is included
 in this game.
\end_layout

\begin_layout Subsubsection
Dead Reckoning
\end_layout

\begin_layout Standard
After developing major parts of the game we noticed that the spaceships
 of other players were not moving smoothly on the screen.
 This happened due to slight variances in bandwidth speed between two nodes.
 We improved the placement of players on screen by implementing dead reckoning.
 Dead reckoning tries to calculate the current position of an object by
 having a previous location, the elapsed time and the speed and direction
 the object moved since the last location.
\end_layout

\begin_layout Standard
As time we take the time that has elapsed since the last position arrived.
 As speed and direction we take the values from the previous packet.
 As soon as we receive a new packet with a real location, we smoothly move
 the spaceship from the calculated fake position to the actual deterministic
 location.
\end_layout

\begin_layout Standard
Implementing this feature now makes sure that movements look very natural
 at all times.
\end_layout

\end_body
\end_document
