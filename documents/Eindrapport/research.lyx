#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
WebRTC
\begin_inset CommandInset label
LatexCommand label
name "sub:WebRTC"

\end_inset


\end_layout

\begin_layout Standard
As WebRTC is an integral part of the project, a lot of early research has
 gone into reading the official documentation and producing prototypes that
 demonstrate the uses of the technology.
 In this phase of the project we've experimented with different techniques
 for establishing connections, methods of sending and receiving data and
 developing a useful application structure.
\end_layout

\begin_layout Subsubsection
Initialization
\end_layout

\begin_layout Standard
Before a WebRTC peer-to-peer connection is made, the peers first have to
 exchange identifying information and agree on several aspects of the connection.
 Since there's no connection between the peers yet, this communication can't
 be direct, and has to be routed through a third party both peers are in
 some way connected with.
 The official W3C WebRTC specifications do not provide any details on how
 to go about this exchange of information, but we identified several different
 ways.
 One way is to use AJAX requests to a web server, which in turn routes informati
on from one peer to the other, but this has the disadvantage that either
 both peers have to be aware that the other peer is requesting a connection,
 or that the use of continuous AJAX polling is required.
 Another way to establish the connection is to have all peers to be connected
 to a web server using a WebSocket, which is always available and open for
 sending and receiving data.
 
\end_layout

\begin_layout Subsection
Peer-to-Peer
\begin_inset CommandInset label
LatexCommand label
name "sub:Peer-to-Peer"

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Assignment-formulation"

\end_inset

 we already have defined that the type of peer-to-peer application will
 be a browser based game.
 Out research on peer-to-peer networks will consequently be related to our
 choice.
\end_layout

\begin_layout Subsubsection
Node heterogeneity
\end_layout

\begin_layout Standard
Our goal is to create a stable, fast performing network with WebRTC technology.
 It is important to realize that every node which wants to connect to the
 network is different, and thus will not perform the on same way.
 According to Jan Sacha 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset

, a node has a lot of characteristics to consider.
 We will sum them up.
\end_layout

\begin_layout Standard
A node has a session duration defined by the amount of time a node is in
 the network or expected to stay in the network.
 In our case of an arcade action game, a player will join for a period between
 1 minute and 1 hour.
 A small session duration will make the stability of network vulnerable.
\end_layout

\begin_layout Standard
Availability of the node is the next property, defined by a fraction of
 time a node spends in the network within longer period of time.
 This is important for availability of files for file sharing purposes.
 The files that should be distributed through the network are the library
 files - to make connection to peers and the game files - to actually play
 the game.
 Availability plays a role if the game files are being delivered through
 different peers.
 Longer availability means more peers in network what means a more stable
 network and better delivery.
 However this property is less important.
\end_layout

\begin_layout Standard
A more important characteristic of a node is bandwidth.
 Our application should be able to send a huge amount of data to all connected
 nodes.
 This could be a bottleneck for network heavy applications.
 Therefore by structuring a network, this can be an important factor.
\end_layout

\begin_layout Standard
Sending a large amount of data leads to processing a large amount of data.
 That is why memory, CPU, GPU and disk space can be important not only for
 the game experience but also for the network.
 Also the problems processing a game can lead to slower processing of the
 network functionality.
\end_layout

\begin_layout Standard
Some of the nodes can be located behind firewalls and be only able to connect
 to a limited amount of nodes.
 It is definitely our goal to ensure everyone who is able make a WebRTC
 connection to at least one of the nodes (and that is not so hard, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:WebRTC"

\end_inset

 ), can communicate to all others.
 Therefor, we have to provide a path that allows every node to reach every
 other node.
 This connectivity is one of our key properties that allows our players
 to play the game with each other.
\end_layout

\begin_layout Standard
Jan Sacha also mentions the amount of shared files and the amount of traffic
 generated by the nodes as properties of the nodes.
 This is mostly important for file sharing purposes.
\end_layout

\begin_layout Standard
According to Sharad Agarwal and Jacob R.
 Lorch
\begin_inset CommandInset citation
LatexCommand cite
key "Agarwal:2009:MOG:1594977.1592605"

\end_inset

, one of the most important properties for online peer-to-peer games is
 the latency.
 Reaction speed is essential for the real-time arcade action games.
 A small delay can be experienced as laggy by users.
 Therefore, latency will be one of the key node properties, we should consider
 while implementing our network.
\end_layout

\begin_layout Subsubsection
Structuring the network
\end_layout

\begin_layout Standard
Now we know that there are differences between nodes, we should pick a network
 topology which fits the best for our network technology - WebRTC and our
 goal application - arcade action game.
 A lot of research is done in this field, so we decided to check the existent
 topologies and in first to not try to come up with our own.
\end_layout

\begin_layout Standard
WebRTC is a new technology and first we decided to run some tests of how
 the WebRTC unstructured overlay network will perform, so if all nodes will
 be connected to all other nodes and send a significant amount data through.
 Already after 15 nodes the network started to display connection errors
 and sometimes failed to successfully send a message.
 Off course, you can quickly see that this is not the way to go, so we should
 structure the network.
\end_layout

\begin_layout Standard
Leitao 
\begin_inset CommandInset citation
LatexCommand cite
key "Leit√£o_onthe"

\end_inset

 summarized a couple of guidelines that introduce some degree of structure
 in randomly overlay networks.
\end_layout

\begin_layout Enumerate
So should every adaptation of the system involve a limited number of nodes.
\end_layout

\begin_layout Enumerate
Each adaptation should also use limited information to reduce communication
 between nodes for scalability purposes.
\end_layout

\begin_layout Enumerate
The adaption mechanisms should not break the network if a node functions
 with a limited or incorrect information.
 This can be expected in large networks.
\end_layout

\begin_layout Enumerate
A network should strive to keep an up-to-date track of all nodes connected
 to the network to ensure the connectivity of each node is constant.
\end_layout

\begin_layout Enumerate
The adaption mechanisms should dynamically improve the network stability.
\end_layout

\begin_layout Enumerate
Different application should be able to be run on the designed overlay network.
\end_layout

\begin_layout Standard
These best practices should be taken in mind while researching the different
 implementation of the overlay networks.
 Especially guideline 4 is very important for our game application.
 Each player should always be aware of all other players participating in
 the game and he should always have a route to communicate with him with
 as little as possible delay.
 This will be our base by investigating the peer-to-peer network topologies.
\end_layout

\begin_layout Subsubsection
Supernode topologies and approaches
\end_layout

\begin_layout Standard
A supernode is a node who acts like a server to a group of clients, we can
 compare it to parent-child relationship.
 A supernode also acts as an equal to other supernodes - a sibling relationship.
 These connected supernodes form a supernode overlay network which handles
 the core functionality of the network.
 Network topologies that implement an supernode structure make use of the
 heterogeneity of the nodes.
 There is a lot of research done on supernode topologies..
 The key question in here is: How many supernodes are desired and which
 node is the best candidate? 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset

 
\end_layout

\begin_layout Standard
Because of the enormous amount of the supernode algorithms we will split
 them in different categories.
 Jan Sacha defines four groups that use a different supernode election mechanism
s:
\end_layout

\begin_layout Enumerate

\series bold
Simple approaches
\series default
 are the first generation algorithms.
 Here are no supernode election processes described or the election approach
 is very simple or static.
 Some algorithms in this group use a central server to assign a supernode.
 Simple approaches of supernode selection don't produce an optimal network
 topology, so we disregard this class.
\end_layout

\begin_layout Enumerate

\series bold
Group based
\series default
 algorithms split a node population in different groups and elect a supernode
 independently.
 The grouped are usually split by peer properties like network proximity.
 Group based algorithms have as advantage that a global supernode election
 problem can be decomposed in local group-level supernode selection problem.
 As disadvantage are these groups hard to create and manage
\end_layout

\begin_layout Enumerate

\series bold
DHT based
\series default
 algorithms make use of the well-know DHT peer-to-peer system.
 In this class nodes use a DHT overlay to discover which nodes are close
 to them in a DHT defined space.
 The advantage of the DHT-based systems is that parent-children clusters
 can be split and merged very easily.
 However these algorithms can not real time select a supernode and distribute
 the clients to the supernodes.
 This is an important aspect of our game, so we disregard this class.
\end_layout

\begin_layout Enumerate

\series bold
Adaptive algorithms
\series default
 elect supernodes based on pre defined rules, for example: the maximum number
 of clients a supernode can have.
\end_layout

\begin_layout Standard
We chose the group based algorithms to go further with because of the decentrali
zed approach of supernode selection.
 However the rule sets of the adaptive algorithms can also be very valuable
 during the implementation of the group base algorithm.
\end_layout

\begin_layout Subsubsection
Group based network systems
\end_layout

\begin_layout Standard
We would like to compare a couple of group based systems below.
 They are divided into three classes by how nodes are organized.
 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset


\end_layout

\begin_layout Enumerate
Location-based systems are organized by their physical location, defined
 for example by communication latency between two nodes.
\end_layout

\begin_layout Enumerate
Semantic based systems are organized by their semantics.
 For example it could be a node position in the game world.
\end_layout

\begin_layout Enumerate
Grid based systems are organized by an administrative domain.
 The large-scale grid consists of small-scale grids what are actually a
 network themselves.
\end_layout

\begin_layout Standard
The choice of structuring the nodes was a tough one.
 Location based systems are better for optimal communication for all purposes,
 while semantic based systems can implement the structure for specific purposes.
 In our game example for example, you would not send any data to a player
 who can not interact with you.
 We choose to implement a location-based structure to keep our library useful
 for the different purposes.
\end_layout

\begin_layout Subsubsection
Location based systems
\end_layout

\begin_layout Subsection
MMOG
\end_layout

\begin_layout Standard
The game is our second delivery with the only purpose to demonstrate the
 functionality of our networkinglibrary in a fun way.
 Therefore we did not properly design a game and just brainstormed about
 gameideas until we found something we all liked.
\end_layout

\begin_layout Standard
For a game we had two different options.
 We would either make a fast-paced action game where low latency is essential
 or a role-playing-game where a low latency was not absolutely necessary.
\end_layout

\begin_layout Standard
Because WebRTC offers low-latency data channels we picked the first option.
 We did not want to create a generic first-person shooter though because
 that did not interest anyone in our group.
\end_layout

\begin_layout Standard
We did pick a 3D dogfighting game around a planet with little 
\begin_inset Quotes eld
\end_inset

alien
\begin_inset Quotes erd
\end_inset

-spaceships.
 Every player controls a single spaceship in 3rd person view.
 When the player decends to quickly he or she will crash into the planet
 and die.
 Players can also fire small projectiles that kill other players on hit
 as well.
 To further demonstrate synchronization in the network, the game contains
 a leaderboard showing all accumulated kills and deaths of active players.
\end_layout

\begin_layout Standard
We also picked this gameidea because initially we wanted to create an applicatio
n or game that would make extensive use of orientation sensors in the users
 smartphone.
 This quickly changed to be a desktop game but we still liked the idea of
 being able to control the game with a smartphone.
\end_layout

\begin_layout Standard
Therefore the ability to fly the spaceship by tilting the phone is included
 in this game.
\end_layout

\end_body
\end_document
