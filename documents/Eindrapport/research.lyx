#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
WebRTC
\begin_inset CommandInset label
LatexCommand label
name "sub:WebRTC"

\end_inset


\end_layout

\begin_layout Standard
As WebRTC is an integral part of the project, a lot of early research has
 gone into reading the official W3C WebRTC specifications 
\begin_inset CommandInset citation
LatexCommand cite
key "w3cwebrtcspec"

\end_inset

 and producing prototypes that demonstrate the uses of the technology.
 In this research phase of the project we've experimented with different
 techniques for establishing connections, methods of sending and receiving
 data and developing a useful application structure.
 We will detail our findings on WebRTC below, and provide some insight on
 the inner workings of WebRTC.
\end_layout

\begin_layout Subsubsection
API differences
\end_layout

\begin_layout Standard
In an early phase we discovered that even though the Firefox and Chrome
 web browsers are able to communicate to each other through WebRTC, they
 don't yet use the same JavaScript API for their connections.
 Comparing their respective API's with the official WebRTC specifications
 we found that Chrome's implementation came closest, and keeping in mind
 that we were merely conducting research on WebRTC and not building a consumer
 product, we decided to drop support for Firefox.
 We had our hopes that Firefox would fix their implementation but as of
 this writing this has yet to happen.
 We do expect that Mozilla, Firefox's developer, will eventually bow to
 the official specifications and that our library will work on Firefox as
 well.
\end_layout

\begin_layout Subsubsection
Establishing a peer connection
\begin_inset CommandInset label
LatexCommand label
name "sub:Establishing-a-peer"

\end_inset


\end_layout

\begin_layout Standard
Reliably establishing a peer-to-peer connection between two consumer devices
 is not a trivial matter.
 While web servers are usually designed around accepting connections and
 have their own external IP-address, consumer devices are often protected
 by firewalls and located behind a Network Address Translation service (NAT).
 WebRTC utilizes several technologies to enable peers to connect through
 environments that limit the connectivity of the peers.
\end_layout

\begin_layout Standard
ICE, Interactive Connectivity Establishment 
\begin_inset CommandInset citation
LatexCommand cite
key "ietficespec"

\end_inset

, is a technique for NAT-traversal for UDP-based media streams, although
 in practice ICE isn't limited to UDP alone and can also be applied to TCP.
 ICE makes use of the offer/answer model, where party A sends a connection
 offer to party B including its preferred connection terms and aspects -
 such as bandwidth and protocol version - and party B responds to party
 A with the terms it agrees to.
 These offers and answers are in a format defined by the Session Description
 Protocol, which is a standard created back in 1998 to assist in setting
 up streaming media connections such as Bluetooth headsets streaming audio
 to and from mobile phones and video conferencing where both video and audio
 are streamed between a multitude of entities.
\end_layout

\begin_layout Subsubsection*
STUN and TURN
\end_layout

\begin_layout Standard
ICE heavily relies on STUN, Session Traversal Utilities for NAT 
\begin_inset CommandInset citation
LatexCommand cite
key "ietfstunspec"

\end_inset

, to discover whether or not the application is located behind a NAT.
 STUN does this by calling a so-called STUN-server and query the server
 to retrieve the IP-address and port of the requesting party.
 If this IP-address doesn't match the locally known IP-address (link address),
 the application is located behind a NAT.
 The discovered external IP-address and port are then included in the connection
 offer or answer by encoding them into the SDP packet.
\end_layout

\begin_layout Standard
TURN, Traversal Using Relay NAT 
\begin_inset CommandInset citation
LatexCommand cite
key "ietfturnspec"

\end_inset

, is an extension on STUN.
 It allows ICE connections to be relayed by a TURN-server, which means that
 even when the user is behind an aggressive firewall or problematic NAT,
 ICE connections can be established by having the TURN-server relay all
 packets.
 In contrast to STUN-servers, which are freely provided for public use by
 a number of entities, TURN-servers are usually not free and have to be
 self hosted or rented from a third party.
\end_layout

\begin_layout Subsubsection*
Signalling channels
\end_layout

\begin_layout Standard
Before a peer connection is established, the peers have to exchange the
 connectivity information in the form of SDP packets.
 Since there's no connection between these peers yet, these packets have
 to be routed through a third party that can communicate with either node,
 also called a signalling channel.
 The official W3C WebRTC specifications do not provide a detailed description
 on what form this signalling channel should take on and instead leave it
 to the developer to guide the exchange of SDP packets.
 We identified several possible manners to achieve this initialization.
\end_layout

\begin_layout Itemize
Using a web server, one can use AJAX requests which in turn routes information
 from one peer to the other, but this has the disadvantage that any peer
 has to be aware that the other peer is requesting a connection, or that
 the use of continuous AJAX polling, continuously requesting the server
 for an update, is required.
\end_layout

\begin_layout Itemize
Another way to establish the connection is to have all peers connected to
 a web server using a WebSocket, a technology which provides full continuous
 communication between the browser and a web server, and is always available
 and open for sending and receiving data.
 SDPs can then be easily routed through this web server.
\end_layout

\begin_layout Itemize
Apart from that, it would in theory be possible to use a DNS discovery technique
s such as Apple's Bonjour to detect WebRTC nodes on the local network, but
 this isn't (yet) possible without the use third party plugins.
\end_layout

\begin_layout Itemize
Aside from using a web server or non-existent technology, it would also
 be possible, although cumbersome, to exchange the information in manually,
 like using QR-encoding to encode the SDP into an image which can be scanned
 by another machine.
\end_layout

\begin_layout Subsubsection*
WebSockets
\end_layout

\begin_layout Standard
The choice of which technology to use for the signalling channel was a relativel
y easy one: WebSockets seemed to be the best technology for our purposes
 as it has very few downsides and provides a reliable way for exchanging
 data, and this choice was backed up by numerous sources on the internet
 where the use of WebSockets as signalling channel was ubiquitous among
 WebRTC applications.
 This choice, however, requires a more advanced web server than the well-known
 Apache-PHP-MySQL setup which runs a better part of the internet.
\end_layout

\begin_layout Standard
Among the possibilities, which also included a custom Java server or Ruby-on-Rai
ls, we found that a Node.js server best fit our needs, not the least because
 Node.js, like web browsers, runs JavaScript.
 This means that both client and server are able to run the same code, which
 has the advantages of slimming down the code base by avoiding the duplication
 of functionality and make the whole application less error prone because
 the shared functionality has to be tested only once instead of twice.
 Node.js is perfectly capable of opening and maintaining numerous WebSocket
 connections to provide the signalling functionality we require.
\end_layout

\begin_layout Subsubsection
Exchanging data
\end_layout

\begin_layout Standard
Once a connection has been established, exchanging data is trivial.
 Data channels, for sending raw data, and media streams can be added quite
 easily, although then the connection terms have to be renegotiated.
 This means that that whole offer/answer process has to be repeated, except
 when a data channel is already open the SDP packets don't have to be routed
 through the server but can be sent to the peer directly.
 To avoid renegotiation, one can also add a data channel or media stream
 to the connection prior to generating the offer, so that these are included
 in the initial SDP.
\end_layout

\begin_layout Standard
In our prototypes, we found that data channels are by default rate limited
 to 30 kilobits per second, and if one attempted to send data faster, WebRTC
 would throw mysterious and in-descriptive error messages.
 After some research we discovered that the (automatically generated) SDP
 packet generated at initialization can be simply edited to increase the
 data rate, although this method is very unintuitive and feels a bit awkward.
 For now, however, this seems to be the only way to achieve a useful rate
 of data flow for the channel.
\end_layout

\begin_layout Standard
Another peculiar detail of the data channel implementation in Chrome is
 that the SDP packet to instantiate the WebRTC connection is too large to
 send through a WebRTC data channel.
 This has the implication that, without intervening, peers cannot renegotiate
 their own connections.
 This we found of course to be unacceptable and led to devising a way to
 split up packets before transmitting them, and reassembling them on the
 other side.
 Looking back this is a must-have feature regardless of the size of the
 SDP packet, as this means that we can make any packet arbitrarily large
 without any problems.
\end_layout

\begin_layout Subsection
Peer-to-Peer
\begin_inset CommandInset label
LatexCommand label
name "sub:Peer-to-Peer"

\end_inset


\end_layout

\begin_layout Standard
This chapter describes the first choices we made in our research track and
 explains the road to the desired algorithm.
\end_layout

\begin_layout Subsubsection
Structuring network
\end_layout

\begin_layout Standard
WebRTC is a new technology and first we decided to run some tests of how
 the WebRTC unstructured overlay network will perform, so if all nodes will
 be connected to all other nodes and send a significant amount data through.
 Already after 15 nodes the network started to display connection errors
 and sometimes failed to successfully send a message.
 Of course, we can quickly see that unstructured networks will perform weakly,
 so we should structure the network.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Supernode-topologies-and"

\end_inset

 we discussed different supernode election approaches, at this moment we
 choose one of the approaches to start our research on the best fittable
 topology.
 We choose the group based algorithms as the most suitable for our purposes
 because of the decentralized approach of supernode selection.
 However the rule sets of the adaptive algorithms can also be very valuable
 during the implementation of the group base algorithm.
\end_layout

\begin_layout Subsubsection
Group based network systems
\end_layout

\begin_layout Standard
We would like to compare a couple of group based systems below.
 They are divided into three classes by how nodes are organized 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset

.
\end_layout

\begin_layout Enumerate
Location-based systems are organized by their physical location, defined
 for example by communication latency between two nodes.
\end_layout

\begin_layout Enumerate
Semantic based systems are organized by their semantics.
 For example it could be a node position in the game world.
\end_layout

\begin_layout Enumerate
Grid based systems are organized by an administrative domain.
 The large-scale grid consists of small-scale grids what are actually a
 network themselves.
\end_layout

\begin_layout Standard
The choice of structuring the nodes is a tough one.
 Location based systems are better for optimal communication for all purposes,
 while semantic based systems can implement the structure for specific purposes.
 For example in our game, you would not send any data to a player who can
 not interact with you.
 We choose to implement a location-based structure to keep our library useful
 for the different purposes.
 However during the implementation we should make it easy to switch to different
 organizations.
\end_layout

\begin_layout Subsubsection
Location based systems
\end_layout

\begin_layout Standard
Now we made a choice which type of algorithm we are going to use, we started
 to discover the available systems.
 Below four proposed systems are described.
\end_layout

\begin_layout Enumerate

\series bold
Crown
\series default
 is organizes the network by the prefix of the IP of the user.
 The users with the same prefix are likely to have low latency and high
 bandwidth.
 Nodes in the same group elect a supernode with criteria of high bandwidth,
 high availability, large computational power and a low load 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/euc/WangTL04"

\end_inset

.
 This approach looks very simple and sorting the nodes by IP can be very
 unreliable.
 Also no situation is described when there are too much nodes in the same
 group.
\end_layout

\begin_layout Enumerate

\series bold
Peer-to-peer Asymmetric file Sharing System (PASS)
\series default
, like the name says is designed for sharing files.
 The approach is similar to crown by grouping the nodes by latency.
 An interesting idea here is that PASS introduces a strong single node that
 handles all communication between separate groups.
 Also in PASS a supernode keeps track a backup supernode for case it leaves
 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/saint/KwonR03"

\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
PoPCorn
\series default
 uses an external algorithm like Vivaldi to structure the network in n-dimension
al space.
 First a token is given to a random node, after he decides to negotiate
 with his peers if he may keep it.
 He advertises his token and calculates the combined repulsion force of
 all other tokens in the network.
 If the force is lower than a certain threshold for a certain number of
 time steps, a node may keep it and becomes a supernode.
 This approach does not describe how a token generation works in a real
 time scenario 
\begin_inset CommandInset citation
LatexCommand cite
key "PoPCorn"

\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Wolf and Merz
\series default
 heuristic evolutionary algorithm tries to minimize the distance between
 the supernodes and their clients and the distance between the supernodes.
 This algorithm uses the local search principle to hopefully find a suitable
 solution 
\begin_inset CommandInset citation
LatexCommand cite
key "wolf"

\end_inset

.
 An interesting fact is that 
\begin_inset CommandInset citation
LatexCommand cite
key "wolf"

\end_inset

 illustrates that location based supernode selection is a NP-hard problem.
\end_layout

\begin_layout Standard
We choose for the PoPCorn algorithm because the organization of nodes based
 on latency aims to reach the fastest communication in the network.
 The token distribution principle seems reliable to dynamically elect the
 supernodes dependent of the real time coordinates.
 However a lot of implementation details are missing which offers an opportunity
 to edit PoPCorn to our own needs.
 For example 
\begin_inset CommandInset citation
LatexCommand cite
key "PoPCorn"

\end_inset

 only describes how the supernode selection works if all nodes are already
 in the network connected.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Network-Topology"

\end_inset

 we will describe how we implemented PoPCorn in a continuously changing
 system.
\end_layout

\begin_layout Subsection
MMOG
\end_layout

\begin_layout Standard
The game is our second deliverable with the only purpose to demonstrate
 the functionality of our networking library in a fun way.
 Therefore we did not properly design a game and just brainstormed about
 game ideas until we found something we all liked.
\end_layout

\begin_layout Standard
For a game we had two different options.
 We would either make a fast-paced action game where low latency is essential
 or a role-playing-game where a low latency was not absolutely necessary.
\end_layout

\begin_layout Standard
Because WebRTC offers low-latency data channels we picked the first option.
 We did not want to create a generic first-person shooter though because
 that did not interest anyone in our group.
\end_layout

\begin_layout Standard
We did pick a 3D dog fighting game around a planet with little 
\begin_inset Quotes eld
\end_inset

alien
\begin_inset Quotes erd
\end_inset

-spaceships.
 Every player controls a single spaceship in 3rd person view.
 When the player descends to quickly he or she will crash into the planet
 and die.
 Players can also fire small projectiles that kill other players on hit
 as well.
 To further demonstrate synchronization in the network, the game contains
 a leader board showing all accumulated kills and deaths of active players.
\end_layout

\begin_layout Standard
We also picked this game idea because initially we wanted to create an applicati
on or game that would make extensive use of orientation sensors in the users
 smartphone.
 This quickly changed to be a desktop game but we still liked the idea of
 being able to control the game with a smartphone.
\end_layout

\begin_layout Standard
Therefore the ability to fly the spaceship by tilting the phone is included
 in this game.
\end_layout

\begin_layout Subsubsection
Network utilisation
\end_layout

\begin_layout Standard
In order to keep the game playable with a decent amount of players (around
 50) we need to make sure the game does not use too much bandwidth.
 Currently the game sends five packets per second about the players location
 and velocity.
 Every projectile results in one more packet.
 Bandwidth monitoring showed us that for every additional player in the
 game the total bandwidth usage increased with an average of 0.1 kilobyte/second
 (up- and download together).
 50 people playing together therefore results in an average bandwidth usage
 of 5 kilobyte/second, which is by any terms acceptable.
\end_layout

\end_body
\end_document
