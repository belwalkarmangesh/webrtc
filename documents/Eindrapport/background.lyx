#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
WebRTC
\end_layout

\begin_layout Standard
WebRTC, or Web Real-Time Communication, is an API definition that enables
 the web browser to directly communicate with other web browsers.
 At the time of writing, the API is still being drafted by the World Wide
 Web Consortium (W3C), the main standards organization for the World Wide
 Web.
 WebRTC first saw the light of day when Google open-sourced an early version
 of the API in May 2011, and has evolved to the point that there are now
 advanced implementations in several modern web browsers.
 WebRTC was developed out of a need to allow for richer web applications
 that simply run in the browser without any third party software.
 With the advent of WebRTC, a myriad of completely new web applications
 are being developed that take advantage of the new possibilities it provides,
 for example torrent clients, voice-over-IP applications and customer service
 applications that allow customer clients to share their screens with customer
 service representatives.
 WebRTC is yet another omen of a future where more and more applications
 move from the desktop to the browser, and where consumers never have to
 download and install a piece of software on their operating system ever
 again.
\end_layout

\begin_layout Subsection
Peer-to-Peer
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Standard
A peer-to-peer network is a decentralized distributed network architecture.
 The nodes in the network can communicate with each other without any interactio
n with the central server which keeps a track of all nodes.
 A node usually does not have a full knowledge of the network but instead
 has a limited awareness of the peer it communicates with - it's neighbours.
\end_layout

\begin_layout Paragraph
Infrastructure
\end_layout

\begin_layout Standard
There are countless applications where peer-to-peer technology is used.
 The most known application is definitely file sharing.
 The communication between peers does not proceed through the server and
 therefore peer-to-peer file sharing applications scale better for a huge
 amount of data is being sent through the network and benefit of high bandwidth.
 Some instant messaging software also relies on peer-to-peer networks.
 Beside traffic savings, instant messaging software also profits from the
 ensured privacy because the messages are not stored on some server on Internet.
 Peer-to-peer is also used in many other applications for media streaming
 or content distribution purposes.
\end_layout

\begin_layout Paragraph
Infrastructure
\end_layout

\begin_layout Standard
The simplest form of a peer to peer network is an
\emph on
 unstructured
\emph default
 network.
 Nodes are randomly connected with each other and share data inefficiently.
 All nodes have the same roles in this network.
 It is usually better to implement some kind of overlay network to help
 the nodes to better find each other and transmit data, by creating a
\emph on
 structured
\emph default
 network.
 For example the nodes with more bandwidth operate as supernodes and help
 the other nodes to communicate with each other.
 Node availability can also be one of the ways to structure the network.
 There are many implementations of structured networks, discussed later
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Peer-to-Peer"

\end_inset

.
 The most of them are hybrid what means that a central server is still needed
 for some functions for example when a node enters network.
 In 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Assignment-formulation"

\end_inset

 we already define that the type of peer-to-peer application will be a browser
 based game.
 Our exploration on peer-to-peer networks will consequently be related on
 our choice.
\end_layout

\begin_layout Subsubsection
Node heterogeneity
\begin_inset CommandInset label
LatexCommand label
name "sub:Node-heterogeneity"

\end_inset


\end_layout

\begin_layout Standard
Our goal is to create a stable, fast performing network with WebRTC technology.
 It is important to realize that every node which wants to connect to the
 network is different, and thus will not perform the same way.
 According to Jan Sacha 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset

, a node has a lot of characteristics to consider.
 We will sum them up.
\end_layout

\begin_layout Itemize
A node has a session duration defined by the amount of time a node is in
 the network or expected to stay in the network.
 In our case of an arcade action game, a player will join for a period between
 1 minute and 1 hour.
 A small session duration will make the stability of network vulnerable.
\end_layout

\begin_layout Itemize
Availability of the node is the next property, defined by a fraction of
 time a node spends in the network within longer period of time.
 This is important for availability of files for file sharing purposes.
 The files that should be distributed through the network are the library
 files - to make connection to peers and the game files - to actually play
 the game.
 Availability plays a role if the game files are being delivered through
 different peers.
 Longer availability means more peers in network what means a more stable
 network and better delivery.
 However this property is less important.
\end_layout

\begin_layout Itemize
A more important characteristic of a node is bandwidth.
 Our application should be able to send a huge amount of data to all connected
 nodes.
 This could be a bottleneck for network heavy applications.
 Therefore by structuring a network, this can be an important factor.
\end_layout

\begin_layout Itemize
Sending a large amount of data leads to processing a large amount of data.
 That is why memory, CPU, GPU and disk space can be important not only for
 the game experience but also for the network.
 Also the problems processing a game can lead to slower processing of the
 network functionality.
\end_layout

\begin_layout Itemize
Some of the nodes can be located behind firewalls and be only able to connect
 to a limited amount of nodes.
 It is our goal to ensure that everyone who is able to make a WebRTC connection
 to at least one of the nodes (and that is not so hard, see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:WebRTC"

\end_inset

 ), can communicate to all others.
 Therefore, we have to provide a path that allows every node to reach every
 other node.
 This connectivity is one of our key properties that allows our players
 to play the game with each other.
\end_layout

\begin_layout Itemize
Jan Sacha also mentions the amount of shared files and the amount of traffic
 generated by the nodes as properties of the nodes.
 This is mostly important for file sharing purposes.
\end_layout

\begin_layout Standard
According to Sharad Agarwal and Jacob R.
 Lorch
\begin_inset CommandInset citation
LatexCommand cite
key "Agarwal:2009:MOG:1594977.1592605"

\end_inset

, one of the most important properties for online peer-to-peer games is
 the latency.
 Reaction speed is essential for the real-time arcade action games.
 A small delay can be experienced as laggy by users.
 Therefore, latency will be one of the key node properties, we should consider
 while implementing our network.
\end_layout

\begin_layout Subsubsection
Structuring the network
\end_layout

\begin_layout Standard
Now we know that there are differences between nodes, we should pick a network
 topology which fits the best for our network technology - WebRTC and our
 goal application - arcade action game.
 A lot of research is done in this field, so we decided to check the existent
 topologies and not to try to come up with our own.
\end_layout

\begin_layout Standard
Leitao 
\begin_inset CommandInset citation
LatexCommand cite
key "Leit√£o_onthe"

\end_inset

 summarized a couple of guidelines that introduce some degree of structure
 in randomly overlay networks.
\end_layout

\begin_layout Enumerate
So should every adaptation of the system involve a limited number of nodes.
\end_layout

\begin_layout Enumerate
Each adaptation should also use limited information to reduce communication
 between nodes for scalability purposes.
\end_layout

\begin_layout Enumerate
The adoption mechanisms should not break the network if a node functions
 with a limited or incorrect information.
 This can be expected in large networks.
\end_layout

\begin_layout Enumerate
A network should strive to keep an up-to-date track of all nodes connected
 to the network to ensure the connectivity of each node is constant.
\end_layout

\begin_layout Enumerate
The adoption mechanisms should dynamically improve the network stability.
\end_layout

\begin_layout Enumerate
Different application should be able to be run on the designed overlay network.
\end_layout

\begin_layout Standard
These best practices should be taken in mind while researching the different
 implementation of the overlay networks.
 Especially guideline 4 is very important for our game application.
 Each player should always be aware of all other players participating in
 the game and he should always have a route to communicate with him with
 as little as possible delay.
 This will be our base by investigating the peer-to-peer network topologies.
\end_layout

\begin_layout Subsubsection
Supernode topologies and election approaches
\begin_inset CommandInset label
LatexCommand label
name "sub:Supernode-topologies-and"

\end_inset


\end_layout

\begin_layout Standard
A supernode is a node which acts like a server to a group of clients, we
 can compare it to parent-child relationship.
 A supernode also acts as an equal to other supernodes - a sibling relationship.
 These connected supernodes form a supernode overlay network which handles
 the core functionality of the network.
 Network topologies that implement an supernode structure make use of the
 heterogeneity of the nodes.
 There is a lot of research done on supernode topologies.
 The key question in here is: How many supernodes are desired and which
 nodes are the best candidates?
\end_layout

\begin_layout Standard
Because of the enormous amount of supernode algorithms we will split them
 in different categories.
 Jan Sacha defines four groups that use a different supernode election mechanism
s 
\begin_inset CommandInset citation
LatexCommand cite
key "sacha2009exploiting"

\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Simple approaches
\series default
 are the first generation algorithms.
 Here are no supernode election processes described or the election approach
 is very simple or static.
 Some algorithms in this group use a central server to assign a supernode.
 Simple approaches of supernode selection don't produce an optimal network
 topology.
\end_layout

\begin_layout Enumerate

\series bold
Group based
\series default
 algorithms split a node population in different groups and elect a supernode
 independently.
 The grouped are usually split by peer properties like network proximity.
 Group based algorithms have as advantage that a global supernode election
 problem can be decomposed in local group-level supernode selection problem.
 As disadvantage are these groups hard to create and manage
\end_layout

\begin_layout Enumerate

\series bold
Distributed Hash Tables (DHT) based
\series default
 algorithms make use of the well-know DHT peer-to-peer system.
 In this class nodes use a DHT overlay to discover which nodes are close
 to them in a DHT defined space.
 The advantage of the DHT-based systems is that parent-children clusters
 can be split and merged very easily.
 However these algorithms can not select a supernode in real time and distribute
 the clients to the supernodes.
 This is an important aspect of our game because of the in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Node-heterogeneity"

\end_inset

 discussed session duration of the nodes.
\end_layout

\begin_layout Enumerate

\series bold
Adaptive algorithms
\series default
 elect supernodes based on pre defined rules, for example: the maximum number
 of clients a supernode can have.
\end_layout

\begin_layout Standard
We will choose the algorithm the fits the best for our purposes in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Peer-to-Peer"

\end_inset

 and will focus on that approach
\end_layout

\begin_layout Subsection
MMOG
\end_layout

\begin_layout Standard
A massively multiplayer online game (MMOG) is a video game with the ability
 to support a large amount of players to play the game together at once.
 As the name states, this has to work over the internet.
 MMOG's can choose to have a persistent world that is ever changing or the
 opposite, a world that is static and immutable.
\end_layout

\begin_layout Subsubsection
Dead Reckoning
\end_layout

\begin_layout Standard
After developing major parts of the game we noticed that the movement of
 other players was not going very smooth at all times.
 This happened due to slight variances in the latency of the networkconnections
 between two players.
 We improved the placement of players on screen by implementing dead reckoning.
 Dead reckoning tries to calculate the current position of an object by
 having a previous location, the elapsed time and the speed and direction
 the object moved since the last location.
\end_layout

\begin_layout Standard
As time we take the time that has elapsed since the last position arrived.
 As speed and direction we take the values from the previous packet.
 As soon as we receive a new packet with a real location, we smoothly move
 the spaceship from the calculated fake position to the actual deterministic
 location.
\end_layout

\begin_layout Standard
Implementing this feature now makes sure that movements look very natural
 at all times.
\end_layout

\end_body
\end_document
