#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
Node Communication
\end_layout

\begin_layout Standard
The basis of the networking library is what we call the unstructured network:
 individual unstructured nodes that have the ability to connect and communicate
 to each other.
 The unstructured network - as the name implies - does not organize or structure
 itself, and requires an additional layer to be fully useful as a peer-to-peer
 network.
 It does have a lot of value: the structured network described in the section
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Network-Topology"

\end_inset

 relies heavily on the functionality provided by the unstructured network.
 Also, individual peer-to-peer connections, such as the connection between
 the game and the mobile controller, are easily established using unstructured
 nodes.
\end_layout

\begin_layout Subsubsection
Event Driven Architecture
\end_layout

\begin_layout Standard
The networking library makes use of an event driven approach to networking.
 Nodes communicate with each other by sending events, packed into Message
 objects, to their peers.
 These messages allow for connected peers to trigger events on each other
 which enables them to orchestrate complex procedures in a precise manner.
\end_layout

\begin_layout Subsubsection
Controllers
\end_layout

\begin_layout Standard
Nodes as well as the server represent a Controller - an interface that provides
 some common functionality like the relaying of messages or responding to
 queries.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/node-server-node.png
	lyxscale 50
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Communication between server and nodes
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Remotes
\end_layout

\begin_layout Standard
All remote communicating entities - a peer, a server or a client - are represent
ed by a Remote sub class.
 The Remote base class provides a common API for all communication, whether
 this communication is implemented by WebSockets or WebRTC.
 This allows network communication to flow transparently via either a peer
 connection or a
\end_layout

\begin_layout Subsubsection
Initialization
\end_layout

\begin_layout Standard
As discussed in the section
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Initialization"

\end_inset

, we route the connection negotiation between two peers via the server using
 WebSockets.
 The server, as other controllers, relays any message where the message
 indicates the controller is not the intended receiver.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/initialisation.png
	lyxscale 50
	width 70line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Initialisation-of-the"

\end_inset

Initialisation of the connection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With assistance of 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Initialisation-of-the"

\end_inset

 we can explain how the peer-to-peer connection between two nodes Alice
 and Bob is established.
 
\end_layout

\begin_layout Enumerate
Alice tells the server to ask Bob if he wants to connect to her.
\end_layout

\begin_layout Enumerate
Bob receives the connection request from the server.
\end_layout

\begin_layout Enumerate
If Bob wants to connect, he tells the server to confirm this to Alice.
\end_layout

\begin_layout Enumerate
Alice receives the confirmation from the server, and starts generating a
 connection offer.
\end_layout

\begin_layout Enumerate
Alice calls the STUN-server to determine her external IP-address.
\end_layout

\begin_layout Enumerate
The STUN-server responds with Alice's external IP-address.
\end_layout

\begin_layout Enumerate
Alice now has a complete connection offer and tells the server to forward
 this to Bob.
\end_layout

\begin_layout Enumerate
Bob receives the connection offer and starts generating an answer.
\end_layout

\begin_layout Enumerate
Bob calls the STUN-server to determine his external IP-address.
\end_layout

\begin_layout Enumerate
The STUN-server responds with Bob's external IP-address.
\end_layout

\begin_layout Enumerate
Bob now has a complete connection answer and tells the server to forward
 this to Alice.
\end_layout

\begin_layout Enumerate
Alice receives the answer and starts generating ICE candidates.
\end_layout

\begin_layout Enumerate
When Alice is done generating ICE candidates, she tells the server to relay
 these candidates to Bob.
\end_layout

\begin_layout Enumerate
Bob receives Alice's ICE candidates.
 By now, Bob has also generated ICE candidates.
\end_layout

\begin_layout Enumerate
Bob tells the server to relay his ICE candidates to Alice.
\end_layout

\begin_layout Enumerate
Alice receives the ICE candidates from Bob.
 Alice and Bob now have enough information and the connection is opened.
\end_layout

\begin_layout Subsection
Network Topology
\begin_inset CommandInset label
LatexCommand label
name "sub:Network-Topology"

\end_inset


\end_layout

\begin_layout Standard
In this section the whole network topology is being explained.
 Like in
\begin_inset CommandInset ref
LatexCommand formatted
reference "sub:Peer-to-Peer"

\end_inset

 said, we chose for PoPCorn as supernode election algorithm.
 In this section we will explain how we implemented it.
 PoPCorn uses Vivaldi coordinate system and therefore we will discuss it
 too.
\end_layout

\begin_layout Subsubsection
Server communication
\end_layout

\begin_layout Standard
Our philosophy is to minimize the communication to the server and to aspire
 the stand alone working peer-to-peer system.
 However this may not be at the expense of the network reliability.
 Our network uses server for several purposes.
\end_layout

\begin_layout Enumerate
When going to the game URL, a server distributes the needed files which
 are cached thereafter in the local storage.
\end_layout

\begin_layout Enumerate
When entering network a new node receives a list of existing supernodes
 to chose from and guides the first connection.
\end_layout

\begin_layout Enumerate
When a node becomes supernode and vice versa, a message is sent to the server
 with the mutation information.
\end_layout

\begin_layout Enumerate
Once in a while a supernode updates it's supernode list from the server
 to be 100% sure the list is up to date.
\end_layout

\begin_layout Subsubsection
Vivaldi
\end_layout

\begin_layout Standard
When a node joins the network, it sets it's 3-dimensional coordinates between
 [-2, 2] to ensure the diversity in the coordinates.
 Every 2 seconds a node pings it's peers and gets all theirs positions and
 latencies.
 When all peers answered own position is being calculated.
 For each peer, a node tries to to equalize the latency and the distance
 between two nodes by changing his own position.
 When a node joins the network this process executes fast but after a after
 a couple of steps, approximate position is assumed to be found.
 After that, a position is changing slowly to prevent the oscillating of
 the node 
\begin_inset CommandInset citation
LatexCommand cite
key "vivaldi"

\end_inset

.
\end_layout

\begin_layout Subsubsection
PoPCorn
\end_layout

\begin_layout Standard
Now, we have a coordinate system we can start electing supernodes.
 When a parent can not accept more children it generates a token and distributes
 it to the random child - the game of tokens can begin.
 When a node receives a token, it broadcasts the token to all supernodes
 holding a token.
 The supernodes save the token information and send their own token back.
 After a certain threshold, when all tokens assumed to be received a token
 force is being calculated based on the distances of the other tokens.
 If the token position is close enough to own position, the node becomes
 a supernode.
 Other way all supernodes are being asked to give the closest child to the
 token which receives a that token - and the game of tokens starts over
 
\begin_inset CommandInset citation
LatexCommand cite
key "PoPCorn"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Quirks
\end_layout

\begin_layout Standard
Vivaldi and PoPCorn describe the basic idea of how the network topology
 should look like and how it evolutes.
 However not all details are explained in the papers.
 In this subsection we would like to tell about our additions to the network
 topology.
\end_layout

\begin_layout Standard
Vivaldi performs weak if a node has only one connection to it's parent.
 A stable foundation is needed to find a place in the space.
 That's why every node has connection to at least three supernodes.
 Not only for position purposes but also for backup when a parent leaves.
 The first three nodes which join the network automatically become a supernode.
 New nodes joining the network receive a list of existing supernodes from
 the server and choose a random supernode as parent.
 When a node has settled it gets a recommendation from it's parent with
 the closest supernode.
 If it is worth it, the node switches from parent.
 After switching, we check if a node has children then it can lose it's
 supernode status.
 So is the amount of supernodes dynamically adjusts to the size of the network.
\end_layout

\begin_layout Standard
An interesting detail is how the nodes are getting a parent node.
 Due to continuously changing network where the nodes are changing of the
 supernode status, asynchronous errors are very easy to get.
 That is why we use a query functionality to request adoption of a supernode.
 A supernode can always reject new requests if the situation has changed.
\end_layout

\begin_layout Standard
As just said, asynchronous requests make the network vulnerable for errors.
 We implemented some functionality that can automatically detect and fix
 errors.
 Checking for inconsistencies is an important part of the network to ensure
 the network keeps running.
\end_layout

\begin_layout Subsection
Game
\end_layout

\begin_layout Standard
Our game 
\noun on
Orbit Impossible
\noun default
 is a HTML5 3D dogfighting game.
 All players start in a small aerial vehicle on the surface of a planet.
 From here they can fly around the planet and shoot down other players with
 little bullets.
 Because we wanted the game to be easily playable for short amount of time
 without a steep learning curve, we picked the immutable world variant.
 An immutable world is easy to understand and does not require much explanation
 to the user.
 The only interaction a player can have with the world is landing on it,
 and when approaching with a too large velocity, crashing into it.
 The other possible interaction is shooting down other players.
\end_layout

\begin_layout Standard
To play the game, the user visits a website.
 While the game is loading in the background and a connection to the network
 is established, the user gets some basic information about the game.
 After clicking this screen away an option to pick the controller is presented.
 Currently two different options are available: Controlling by mouse and
 keyboard or controlling via an Google Android smartphone (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Controller-selection-in"

\end_inset

).
 In the case of mouse and keyboard, the control mapping is shown (figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Mouse/Keyboard-control-mapping"

\end_inset

).
 When the mobile phone is selected, the user is asked to scan a QR code
 to connect his or her phone to the game.
 After this is done, a similar control mapping is shown.
\end_layout

\begin_layout Standard
After pressing the boost button, which is used to ascend from the planet,
 the player spawns in the world and starts to fly upwards.
 The goal of the game is to kill as many opponents as possible while trying
 not to die yourself.
 Killing other players is possible by shooting tiny projectiles from a cannon
 attached to the bottom of the spacecraft.
 When a player dies, scores for the victim and the killer are updated in
 the scoreboard and the deceased player can respawn by pressing the boost
 button again.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/controller-selection.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Controller selection in Orbit Impossible
\begin_inset CommandInset label
LatexCommand label
name "fig:Controller-selection-in"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/mouse-keyboard-controls.png
	width 100line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Mouse/Keyboard control mapping in Orbit Impossible
\begin_inset CommandInset label
LatexCommand label
name "fig:Mouse/Keyboard-control-mapping"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_body
\end_document
